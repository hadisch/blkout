<?xml version="1.0" encoding="UTF-8"?>
<protocol name="wlr_layer_shell_unstable_v1">
  <copyright>
    Copyright Â© 2017 Drew DeVault

    Permission to use, copy, modify, distribute, and sell this software and
    its documentation for any purpose is hereby granted without fee, provided
    that the above copyright notice appear in all copies and that both that
    copyright notice and this permission notice appear in supporting
    documentation, and that the name of the author not be used in advertising
    or publicity pertaining to distribution of the software without specific,
    written prior permission. The author makes no representations about the
    suitability of this software for any purpose. It is provided "as is"
    without express or implied warranty.

    THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
    INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
    EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
    CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
    USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
  </copyright>

  <interface name="zwlr_layer_shell_v1" version="4">
    <description summary="create surfaces that are layers of the desktop">
      Clients can use this interface to assign the surface_layer role to
      wl_surfaces. Such surfaces are displayed between the desktop background
      and the windows of applications. These surfaces can be used to
      implement certain desktop UI components such as a launcher or a
      status bar.

      Elements of the shell's UI can use this protocol to place themselves
      above or below other windows in specific locations of the screen.

      Warning! The protocol described in this file is currently in the testing
      phase. Backward compatible changes may be added together with the
      corresponding interface version bump. Backward incompatible changes can
      only be done by creating a new major version of the extension.
    </description>

    <request name="get_layer_surface">
      <description summary="create a layer_surface from a surface">
        Create a layer surface for an existing surface. This assigns the role
        of layer_surface, or raises a protocol error if another role is
        already assigned.

        Creating a layer surface from a wl_surface which has a buffer attached
        or committed is a client error, and any attempts by a client to attach
        or manipulate a buffer prior to the first layer_surface.configure call
        must also be treated as errors.

        You may pass NULL for output to allow the compositor to decide which
        output to use. Generally this will be the one that the user most
        recently interacted with.

        Clients can specify a set of inputs a surface can receive. This is
        specified by passing the desired value for keyboard_interactivity in
        the get_layer_surface request.

        The namespace is intended as a functional description of the surface
        for purposes of compositor policies. Examples might be "osk" for an
        on-screen keyboard, "launcher" for a v launcher, or "lockscreen" for
        a lockscreen.

        If the namespace is the empty string, the compositor may assume that
        the client has no namespace. Currently there are no compositor
        policies that depend on the surface namespace. If the compositor
        decides that a client does not have a valid namespace, the compositor
        may close the surface.
      </description>
      <arg name="id" type="new_id" interface="zwlr_layer_surface_v1"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
      <arg name="layer" type="uint" enum="layer" summary="layer to add this surface to"/>
      <arg name="namespace" type="string" summary="scoping namespace"/>
    </request>

    <request name="destroy" type="destructor" since="3">
      <description summary="destroy the layer_shell object">
        This request indicates that the client will not use the layer_shell
        object any more. Objects that have been created through this instance
        are not affected.
      </description>
    </request>

    <enum name="error">
      <entry name="role" value="0" summary="wl_surface has another role"/>
      <entry name="invalid_layer" value="1" summary="layer value is invalid"/>
      <entry name="already_constructed" value="2"
             summary="wl_surface has a buffer attached or committed"/>
    </enum>

    <enum name="layer">
      <description summary="available layers for surfaces">
        These values indicate which layers a surface can be rendered to. They
        are ordered by z depth, bottom-most first. Traditional shell surfaces
        will typically be rendered between the bottom and top layers.
        Fullscreen shell surfaces are typically rendered at the top layer.
        Multiple surfaces can share a single layer, and ordering within a
        single layer is undefined.
      </description>
      <entry name="background" value="0"/>
      <entry name="bottom" value="1"/>
      <entry name="top" value="2"/>
      <entry name="overlay" value="3"/>
    </enum>
  </interface>

  <interface name="zwlr_layer_surface_v1" version="4">
    <description summary="layer metadata interface">
      An interface that may be implemented by a wl_surface, for surfaces that
      are designed to be rendered as a layer of a stacked desktop-like
      environment.

      Layer surface state (layer, size, anchor, exclusive zone,
      margin, interactivity) is double-buffered, and will be applied at the
      time wl_surface.commit of the corresponding wl_surface is called.

      Attaching a null buffer to a layer surface unmaps it.

      Unmapping a layer_surface means that the surface cannot be shown by the
      compositor until it is explicitly mapped again. The layer_surface
      returns to the state it had right after layer_shell.get_layer_surface.
      The client can re-map the surface by performing a commit without any
      buffer attached, waiting for a configure event and handling it as usual
      (see layer_surface.configure).

      Explicitly destroying, or setting the parent of a xdg_popup that
      was used as the parent of a layer_surface is undefined and may be
      treated as a protocol error.
    </description>

    <request name="set_size">
      <description summary="sets the size of the surface">
        Sets the size of the surface in surface-local coordinates. The
        compositor will display the surface centered with respect to its
        anchors.

        If you pass 0 for either value, the compositor will assign it and
        inform you of the assignment in the configure event. You must set your
        anchor to opposite edges in the axis you omit; not doing so is a
        protocol error. Both values are 0 by default.

        Size is double-buffered, see wl_surface.commit.
      </description>
      <arg name="width" type="uint"/>
      <arg name="height" type="uint"/>
    </request>

    <request name="set_anchor">
      <description summary="configures the anchor point of the surface">
        Requests that the compositor anchor the surface to the specified edges
        and corners. If two orthogonal edges are specified (e.g. 'top' and
        'left'), then the anchor point will be the intersection of the edges
        (e.g. the top left corner of the output); otherwise, the anchor point
        will be centered on that edge, or in the center of the output if none
        is specified.

        Anchor is double-buffered, see wl_surface.commit.
      </description>
      <arg name="anchor" type="uint" enum="anchor"/>
    </request>

    <request name="set_exclusive_zone">
      <description summary="configures the exclusive geometry of this surface">
        Requests that the compositor avoids occluding an area with other
        surfaces. The compositor's use of this information is
        implementation-dependent - do not assume that this region will not
        actually be occluded.

        A positive value is only meaningful if the surface is anchored to one
        edge or an edge and both perpendicular edges. If the surface is not
        anchored, anchored to more than one edge (but not the opposite edges),
        or anchored to two opposite edges, the compositor will ignore the
        exclusive zone.

        The exclusive zone is double-buffered, see wl_surface.commit.

        Setting the exclusive zone to -1 is a special case that overrides
        the anchoring rules: the compositor will make sure that this surface
        does not occlude other layer surfaces with a positive exclusive zone,
        but it may be occluded by other surfaces.
      </description>
      <arg name="zone" type="int"/>
    </request>

    <request name="set_margin">
      <description summary="sets a margin from the anchor point">
        Requests that the surface be placed some distance away from the anchor
        point on the output, in surface-local coordinates. Setting this value
        for edges you are not anchored to has no effect.

        The exclusive zone includes the margin.

        Margin is double-buffered, see wl_surface.commit.
      </description>
      <arg name="top" type="int"/>
      <arg name="right" type="int"/>
      <arg name="bottom" type="int"/>
      <arg name="left" type="int"/>
    </request>

    <request name="set_keyboard_interactivity">
      <description summary="requests keyboard events">
        Set how keyboard events are delivered to this surface. By default,
        layer shell surfaces do not receive keyboard events; this request can
        be used to enable delivery of keyboard events to a surface.

        Keyboard events from existing wl_keyboard objects are delivered
        normally, as long as the keyboard focus is on the layer shell surface.
        A compositor may also rely on some mechanism to determine the input
        focus and request keyboard events from additional sources.

        If keyboard_interactivity is EXCLUSIVE, then the keyboard focus will
        be taken from the current focus owner, if any.

        If keyboard_interactivity is ON_DEMAND, then the surface may request
        keyboard focus using the standard xdg_activation protocol.

        If keyboard_interactivity is NONE, then the keyboard focus is not
        taken, and keyboard events are not delivered to this surface.

        Values set in this way are double-buffered. They will get applied on
        the next commit.
      </description>
      <arg name="keyboard_interactivity" type="uint"
           enum="keyboard_interactivity"/>
    </request>

    <request name="get_popup">
      <description summary="assign this layer_surface as an xdg_popup parent">
        This assigns an xdg_popup's parent to this layer_surface. This popup
        should have been created via xdg_surface::get_popup with the parent set
        to NULL, and this request must be invoked before committing the popup's
        initial state.
      </description>
      <arg name="popup" type="object" interface="xdg_popup"/>
    </request>

    <request name="ack_configure">
      <description summary="ack a configure event">
        When a configure event is received, if a client commits the
        surface in response to the configure event, then the client
        must make an ack_configure request sometime before the commit
        request, passing along the serial of the configure event.

        If the client receives multiple configure events before it
        can respond to one, it only has to ack the last configure event.
        Acking a configure event that was never sent raises an invalid_serial
        error.

        A client is not required to commit immediately after sending an
        ack_configure request - it may even ack_configure several times
        before its next surface commit.

        A client may send multiple ack_configure requests before committing,
        but only the last request sent before a commit indicates which configure
        event the client really is responding to.
      </description>
      <arg name="serial" type="uint" summary="the serial from the configure event"/>
    </request>

    <request name="destroy" type="destructor">
      <description summary="destroy the layer_surface">
        This request destroys the layer surface.
      </description>
    </request>

    <request name="set_layer" since="2">
      <description summary="change the layer of the surface">
        Change the layer that the surface is rendered on.

        Layer is double-buffered, see wl_surface.commit.
      </description>
      <arg name="layer" type="uint" enum="zwlr_layer_shell_v1.layer"
           summary="layer to move this surface to"/>
    </request>

    <event name="configure">
      <description summary="suggest a surface change">
        The configure event asks the client to resize its surface.

        Clients should arrange their surface for the new states, and then send
        an ack_configure request with the serial sent in this configure event at
        some point before committing the new surface.

        The client is free to dismiss all but the last configure event it
        received.

        The width and height arguments specify the size of the window in
        surface-local coordinates.

        The size is a hint, in the sense that the client is free to ignore it
        if it doesn't resize, pick a smaller size (to satisfy aspect ratio or
        resize in steps of NxM pixels). If the client picks a smaller size and
        is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the
        surface will be centered on this axis.

        If the width or height arguments are zero, it means the client should
        decide its own window dimension.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="width" type="uint"/>
      <arg name="height" type="uint"/>
    </event>

    <event name="closed">
      <description summary="surface should be closed">
        The closed event is sent by the compositor when the surface will no
        longer be shown. The output may have been destroyed or the user may
        have asked for it to be removed. Further changes to the surface will
        be ignored. The client should destroy the resource after receiving
        this event, and create a new surface if they so choose.
      </description>
    </event>

    <enum name="error">
      <entry name="invalid_surface_state" value="0"
             summary="provided surface state is invalid"/>
      <entry name="invalid_size" value="1"
             summary="size is invalid"/>
      <entry name="invalid_anchor" value="2"
             summary="anchor bitfield is invalid"/>
      <entry name="invalid_keyboard_interactivity" value="3"
             summary="keyboard interactivity is invalid"/>
    </enum>

    <enum name="anchor" bitfield="true">
      <entry name="top" value="1" summary="the top edge of the anchor rectangle"/>
      <entry name="bottom" value="2"
             summary="the bottom edge of the anchor rectangle"/>
      <entry name="left" value="4" summary="the left edge of the anchor rectangle"/>
      <entry name="right" value="8"
             summary="the right edge of the anchor rectangle"/>
    </enum>

    <enum name="keyboard_interactivity">
      <description summary="types of keyboard interaction possible for a layer shell surface">
        Types of keyboard interaction possible for layer shell surfaces. The
        rationale for this is twofold: (1) some applications are not interested
        in keyboard events and not allowing them to be sent to the surface is
        a slight optimization; (2) some applications want to ensure that
        keyboard focus remains on the layer shell surface while it is visible.

        If a surface has exclusive keyboard interactivity, it can use the
        wl_keyboard.modifiers event to get notified when a modifier key is
        pressed. In this case, the compositor sends this event to all surfaces
        that have requested it.
      </description>
      <entry name="none" value="0">
        <description summary="no keyboard focus is possible">
          This value indicates that this surface is not interested in keyboard
          events and the compositor should never assign it the keyboard focus.

          This is the default value, set for newly created layer shell surfaces.

          This is useful for e.g. desktop widgets that display information or
          only have interaction with non-keyboard input devices.
        </description>
      </entry>
      <entry name="exclusive" value="1">
        <description summary="request exclusive keyboard focus">
          Request exclusive keyboard focus if this surface is above the shell surface layer.

          For the top and overlay layers, the keyboard focus will always be
          exclusive to this surface (e.g. a fullscreen overlay). For the bottom
          and background layers, no keyboard focus is possible.

          This value is equivalent to the user interactivity model of a regular
          window.
        </description>
      </entry>
      <entry name="on_demand" value="2" since="3">
        <description summary="request regular keyboard focus semantics">
          This requests the compositor to allow this surface to be focused and
          unfocused by the user in an implementation-defined manner. The user
          must be able to unfocus this surface.
        </description>
      </entry>
    </enum>
  </interface>
</protocol>
