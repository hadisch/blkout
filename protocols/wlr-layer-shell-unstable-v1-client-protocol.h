/* Generated by wayland-scanner 1.24.0 */

#ifndef WLR_LAYER_SHELL_UNSTABLE_V1_CLIENT_PROTOCOL_H
#define WLR_LAYER_SHELL_UNSTABLE_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_wlr_layer_shell_unstable_v1 The wlr_layer_shell_unstable_v1 protocol
 * @section page_ifaces_wlr_layer_shell_unstable_v1 Interfaces
 * - @subpage page_iface_zwlr_layer_shell_v1 - create surfaces that are layers of the desktop
 * - @subpage page_iface_zwlr_layer_surface_v1 - layer metadata interface
 * @section page_copyright_wlr_layer_shell_unstable_v1 Copyright
 * <pre>
 *
 * Copyright Â© 2017 Drew DeVault
 *
 * Permission to use, copy, modify, distribute, and sell this software and
 * its documentation for any purpose is hereby granted without fee, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the author not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. The author makes no representations about the
 * suitability of this software for any purpose. It is provided "as is"
 * without express or implied warranty.
 *
 * THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 * </pre>
 */
struct wl_output;
struct wl_surface;
struct xdg_popup;
struct zwlr_layer_shell_v1;
struct zwlr_layer_surface_v1;

#ifndef ZWLR_LAYER_SHELL_V1_INTERFACE
#define ZWLR_LAYER_SHELL_V1_INTERFACE
/**
 * @page page_iface_zwlr_layer_shell_v1 zwlr_layer_shell_v1
 * @section page_iface_zwlr_layer_shell_v1_desc Description
 *
 * Clients can use this interface to assign the surface_layer role to
 * wl_surfaces. Such surfaces are displayed between the desktop background
 * and the windows of applications. These surfaces can be used to
 * implement certain desktop UI components such as a launcher or a
 * status bar.
 *
 * Elements of the shell's UI can use this protocol to place themselves
 * above or below other windows in specific locations of the screen.
 *
 * Warning! The protocol described in this file is currently in the testing
 * phase. Backward compatible changes may be added together with the
 * corresponding interface version bump. Backward incompatible changes can
 * only be done by creating a new major version of the extension.
 * @section page_iface_zwlr_layer_shell_v1_api API
 * See @ref iface_zwlr_layer_shell_v1.
 */
/**
 * @defgroup iface_zwlr_layer_shell_v1 The zwlr_layer_shell_v1 interface
 *
 * Clients can use this interface to assign the surface_layer role to
 * wl_surfaces. Such surfaces are displayed between the desktop background
 * and the windows of applications. These surfaces can be used to
 * implement certain desktop UI components such as a launcher or a
 * status bar.
 *
 * Elements of the shell's UI can use this protocol to place themselves
 * above or below other windows in specific locations of the screen.
 *
 * Warning! The protocol described in this file is currently in the testing
 * phase. Backward compatible changes may be added together with the
 * corresponding interface version bump. Backward incompatible changes can
 * only be done by creating a new major version of the extension.
 */
extern const struct wl_interface zwlr_layer_shell_v1_interface;
#endif
#ifndef ZWLR_LAYER_SURFACE_V1_INTERFACE
#define ZWLR_LAYER_SURFACE_V1_INTERFACE
/**
 * @page page_iface_zwlr_layer_surface_v1 zwlr_layer_surface_v1
 * @section page_iface_zwlr_layer_surface_v1_desc Description
 *
 * An interface that may be implemented by a wl_surface, for surfaces that
 * are designed to be rendered as a layer of a stacked desktop-like
 * environment.
 *
 * Layer surface state (layer, size, anchor, exclusive zone,
 * margin, interactivity) is double-buffered, and will be applied at the
 * time wl_surface.commit of the corresponding wl_surface is called.
 *
 * Attaching a null buffer to a layer surface unmaps it.
 *
 * Unmapping a layer_surface means that the surface cannot be shown by the
 * compositor until it is explicitly mapped again. The layer_surface
 * returns to the state it had right after layer_shell.get_layer_surface.
 * The client can re-map the surface by performing a commit without any
 * buffer attached, waiting for a configure event and handling it as usual
 * (see layer_surface.configure).
 *
 * Explicitly destroying, or setting the parent of a xdg_popup that
 * was used as the parent of a layer_surface is undefined and may be
 * treated as a protocol error.
 * @section page_iface_zwlr_layer_surface_v1_api API
 * See @ref iface_zwlr_layer_surface_v1.
 */
/**
 * @defgroup iface_zwlr_layer_surface_v1 The zwlr_layer_surface_v1 interface
 *
 * An interface that may be implemented by a wl_surface, for surfaces that
 * are designed to be rendered as a layer of a stacked desktop-like
 * environment.
 *
 * Layer surface state (layer, size, anchor, exclusive zone,
 * margin, interactivity) is double-buffered, and will be applied at the
 * time wl_surface.commit of the corresponding wl_surface is called.
 *
 * Attaching a null buffer to a layer surface unmaps it.
 *
 * Unmapping a layer_surface means that the surface cannot be shown by the
 * compositor until it is explicitly mapped again. The layer_surface
 * returns to the state it had right after layer_shell.get_layer_surface.
 * The client can re-map the surface by performing a commit without any
 * buffer attached, waiting for a configure event and handling it as usual
 * (see layer_surface.configure).
 *
 * Explicitly destroying, or setting the parent of a xdg_popup that
 * was used as the parent of a layer_surface is undefined and may be
 * treated as a protocol error.
 */
extern const struct wl_interface zwlr_layer_surface_v1_interface;
#endif

#ifndef ZWLR_LAYER_SHELL_V1_ERROR_ENUM
#define ZWLR_LAYER_SHELL_V1_ERROR_ENUM
enum zwlr_layer_shell_v1_error {
	/**
	 * wl_surface has another role
	 */
	ZWLR_LAYER_SHELL_V1_ERROR_ROLE = 0,
	/**
	 * layer value is invalid
	 */
	ZWLR_LAYER_SHELL_V1_ERROR_INVALID_LAYER = 1,
	/**
	 * wl_surface has a buffer attached or committed
	 */
	ZWLR_LAYER_SHELL_V1_ERROR_ALREADY_CONSTRUCTED = 2,
};
#endif /* ZWLR_LAYER_SHELL_V1_ERROR_ENUM */

#ifndef ZWLR_LAYER_SHELL_V1_LAYER_ENUM
#define ZWLR_LAYER_SHELL_V1_LAYER_ENUM
/**
 * @ingroup iface_zwlr_layer_shell_v1
 * available layers for surfaces
 *
 * These values indicate which layers a surface can be rendered to. They
 * are ordered by z depth, bottom-most first. Traditional shell surfaces
 * will typically be rendered between the bottom and top layers.
 * Fullscreen shell surfaces are typically rendered at the top layer.
 * Multiple surfaces can share a single layer, and ordering within a
 * single layer is undefined.
 */
enum zwlr_layer_shell_v1_layer {
	ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND = 0,
	ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM = 1,
	ZWLR_LAYER_SHELL_V1_LAYER_TOP = 2,
	ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY = 3,
};
#endif /* ZWLR_LAYER_SHELL_V1_LAYER_ENUM */

#define ZWLR_LAYER_SHELL_V1_GET_LAYER_SURFACE 0
#define ZWLR_LAYER_SHELL_V1_DESTROY 1


/**
 * @ingroup iface_zwlr_layer_shell_v1
 */
#define ZWLR_LAYER_SHELL_V1_GET_LAYER_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_shell_v1
 */
#define ZWLR_LAYER_SHELL_V1_DESTROY_SINCE_VERSION 3

/** @ingroup iface_zwlr_layer_shell_v1 */
static inline void
zwlr_layer_shell_v1_set_user_data(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwlr_layer_shell_v1, user_data);
}

/** @ingroup iface_zwlr_layer_shell_v1 */
static inline void *
zwlr_layer_shell_v1_get_user_data(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwlr_layer_shell_v1);
}

static inline uint32_t
zwlr_layer_shell_v1_get_version(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwlr_layer_shell_v1);
}

/**
 * @ingroup iface_zwlr_layer_shell_v1
 *
 * Create a layer surface for an existing surface. This assigns the role
 * of layer_surface, or raises a protocol error if another role is
 * already assigned.
 *
 * Creating a layer surface from a wl_surface which has a buffer attached
 * or committed is a client error, and any attempts by a client to attach
 * or manipulate a buffer prior to the first layer_surface.configure call
 * must also be treated as errors.
 *
 * You may pass NULL for output to allow the compositor to decide which
 * output to use. Generally this will be the one that the user most
 * recently interacted with.
 *
 * Clients can specify a set of inputs a surface can receive. This is
 * specified by passing the desired value for keyboard_interactivity in
 * the get_layer_surface request.
 *
 * The namespace is intended as a functional description of the surface
 * for purposes of compositor policies. Examples might be "osk" for an
 * on-screen keyboard, "launcher" for a v launcher, or "lockscreen" for
 * a lockscreen.
 *
 * If the namespace is the empty string, the compositor may assume that
 * the client has no namespace. Currently there are no compositor
 * policies that depend on the surface namespace. If the compositor
 * decides that a client does not have a valid namespace, the compositor
 * may close the surface.
 */
static inline struct zwlr_layer_surface_v1 *
zwlr_layer_shell_v1_get_layer_surface(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1, struct wl_surface *surface, struct wl_output *output, uint32_t layer, const char *namespace)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_shell_v1,
			 ZWLR_LAYER_SHELL_V1_GET_LAYER_SURFACE, &zwlr_layer_surface_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_shell_v1), 0, NULL, surface, output, layer, namespace);

	return (struct zwlr_layer_surface_v1 *) id;
}

/**
 * @ingroup iface_zwlr_layer_shell_v1
 *
 * This request indicates that the client will not use the layer_shell
 * object any more. Objects that have been created through this instance
 * are not affected.
 */
static inline void
zwlr_layer_shell_v1_destroy(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_shell_v1,
			 ZWLR_LAYER_SHELL_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_shell_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef ZWLR_LAYER_SURFACE_V1_ERROR_ENUM
#define ZWLR_LAYER_SURFACE_V1_ERROR_ENUM
enum zwlr_layer_surface_v1_error {
	/**
	 * provided surface state is invalid
	 */
	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SURFACE_STATE = 0,
	/**
	 * size is invalid
	 */
	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SIZE = 1,
	/**
	 * anchor bitfield is invalid
	 */
	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_ANCHOR = 2,
	/**
	 * keyboard interactivity is invalid
	 */
	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_KEYBOARD_INTERACTIVITY = 3,
};
#endif /* ZWLR_LAYER_SURFACE_V1_ERROR_ENUM */

#ifndef ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM
#define ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM
enum zwlr_layer_surface_v1_anchor {
	/**
	 * the top edge of the anchor rectangle
	 */
	ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP = 1,
	/**
	 * the bottom edge of the anchor rectangle
	 */
	ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM = 2,
	/**
	 * the left edge of the anchor rectangle
	 */
	ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT = 4,
	/**
	 * the right edge of the anchor rectangle
	 */
	ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT = 8,
};
#endif /* ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM */

#ifndef ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM
#define ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM
/**
 * @ingroup iface_zwlr_layer_surface_v1
 * types of keyboard interaction possible for a layer shell surface
 *
 * Types of keyboard interaction possible for layer shell surfaces. The
 * rationale for this is twofold: (1) some applications are not interested
 * in keyboard events and not allowing them to be sent to the surface is
 * a slight optimization; (2) some applications want to ensure that
 * keyboard focus remains on the layer shell surface while it is visible.
 *
 * If a surface has exclusive keyboard interactivity, it can use the
 * wl_keyboard.modifiers event to get notified when a modifier key is
 * pressed. In this case, the compositor sends this event to all surfaces
 * that have requested it.
 */
enum zwlr_layer_surface_v1_keyboard_interactivity {
	/**
	 * no keyboard focus is possible
	 *
	 * This value indicates that this surface is not interested in
	 * keyboard events and the compositor should never assign it the
	 * keyboard focus.
	 *
	 * This is the default value, set for newly created layer shell
	 * surfaces.
	 *
	 * This is useful for e.g. desktop widgets that display information
	 * or only have interaction with non-keyboard input devices.
	 */
	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_NONE = 0,
	/**
	 * request exclusive keyboard focus
	 *
	 * Request exclusive keyboard focus if this surface is above the
	 * shell surface layer.
	 *
	 * For the top and overlay layers, the keyboard focus will always
	 * be exclusive to this surface (e.g. a fullscreen overlay). For
	 * the bottom and background layers, no keyboard focus is possible.
	 *
	 * This value is equivalent to the user interactivity model of a
	 * regular window.
	 */
	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_EXCLUSIVE = 1,
	/**
	 * request regular keyboard focus semantics
	 *
	 * This requests the compositor to allow this surface to be
	 * focused and unfocused by the user in an implementation-defined
	 * manner. The user must be able to unfocus this surface.
	 * @since 3
	 */
	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ON_DEMAND = 2,
};
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ON_DEMAND_SINCE_VERSION 3
#endif /* ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM */

/**
 * @ingroup iface_zwlr_layer_surface_v1
 * @struct zwlr_layer_surface_v1_listener
 */
struct zwlr_layer_surface_v1_listener {
	/**
	 * suggest a surface change
	 *
	 * The configure event asks the client to resize its surface.
	 *
	 * Clients should arrange their surface for the new states, and
	 * then send an ack_configure request with the serial sent in this
	 * configure event at some point before committing the new surface.
	 *
	 * The client is free to dismiss all but the last configure event
	 * it received.
	 *
	 * The width and height arguments specify the size of the window in
	 * surface-local coordinates.
	 *
	 * The size is a hint, in the sense that the client is free to
	 * ignore it if it doesn't resize, pick a smaller size (to satisfy
	 * aspect ratio or resize in steps of NxM pixels). If the client
	 * picks a smaller size and is anchored to two opposite anchors
	 * (e.g. 'top' and 'bottom'), the surface will be centered on this
	 * axis.
	 *
	 * If the width or height arguments are zero, it means the client
	 * should decide its own window dimension.
	 */
	void (*configure)(void *data,
			  struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1,
			  uint32_t serial,
			  uint32_t width,
			  uint32_t height);
	/**
	 * surface should be closed
	 *
	 * The closed event is sent by the compositor when the surface
	 * will no longer be shown. The output may have been destroyed or
	 * the user may have asked for it to be removed. Further changes to
	 * the surface will be ignored. The client should destroy the
	 * resource after receiving this event, and create a new surface if
	 * they so choose.
	 */
	void (*closed)(void *data,
		       struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1);
};

/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
static inline int
zwlr_layer_surface_v1_add_listener(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1,
				   const struct zwlr_layer_surface_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwlr_layer_surface_v1,
				     (void (**)(void)) listener, data);
}

#define ZWLR_LAYER_SURFACE_V1_SET_SIZE 0
#define ZWLR_LAYER_SURFACE_V1_SET_ANCHOR 1
#define ZWLR_LAYER_SURFACE_V1_SET_EXCLUSIVE_ZONE 2
#define ZWLR_LAYER_SURFACE_V1_SET_MARGIN 3
#define ZWLR_LAYER_SURFACE_V1_SET_KEYBOARD_INTERACTIVITY 4
#define ZWLR_LAYER_SURFACE_V1_GET_POPUP 5
#define ZWLR_LAYER_SURFACE_V1_ACK_CONFIGURE 6
#define ZWLR_LAYER_SURFACE_V1_DESTROY 7
#define ZWLR_LAYER_SURFACE_V1_SET_LAYER 8

/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_CLOSED_SINCE_VERSION 1

/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_SET_SIZE_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_SET_ANCHOR_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_SET_EXCLUSIVE_ZONE_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_SET_MARGIN_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_SET_KEYBOARD_INTERACTIVITY_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_GET_POPUP_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_ACK_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwlr_layer_surface_v1
 */
#define ZWLR_LAYER_SURFACE_V1_SET_LAYER_SINCE_VERSION 2

/** @ingroup iface_zwlr_layer_surface_v1 */
static inline void
zwlr_layer_surface_v1_set_user_data(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwlr_layer_surface_v1, user_data);
}

/** @ingroup iface_zwlr_layer_surface_v1 */
static inline void *
zwlr_layer_surface_v1_get_user_data(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwlr_layer_surface_v1);
}

static inline uint32_t
zwlr_layer_surface_v1_get_version(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Sets the size of the surface in surface-local coordinates. The
 * compositor will display the surface centered with respect to its
 * anchors.
 *
 * If you pass 0 for either value, the compositor will assign it and
 * inform you of the assignment in the configure event. You must set your
 * anchor to opposite edges in the axis you omit; not doing so is a
 * protocol error. Both values are 0 by default.
 *
 * Size is double-buffered, see wl_surface.commit.
 */
static inline void
zwlr_layer_surface_v1_set_size(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t width, uint32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_SET_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, width, height);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Requests that the compositor anchor the surface to the specified edges
 * and corners. If two orthogonal edges are specified (e.g. 'top' and
 * 'left'), then the anchor point will be the intersection of the edges
 * (e.g. the top left corner of the output); otherwise, the anchor point
 * will be centered on that edge, or in the center of the output if none
 * is specified.
 *
 * Anchor is double-buffered, see wl_surface.commit.
 */
static inline void
zwlr_layer_surface_v1_set_anchor(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t anchor)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_SET_ANCHOR, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, anchor);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Requests that the compositor avoids occluding an area with other
 * surfaces. The compositor's use of this information is
 * implementation-dependent - do not assume that this region will not
 * actually be occluded.
 *
 * A positive value is only meaningful if the surface is anchored to one
 * edge or an edge and both perpendicular edges. If the surface is not
 * anchored, anchored to more than one edge (but not the opposite edges),
 * or anchored to two opposite edges, the compositor will ignore the
 * exclusive zone.
 *
 * The exclusive zone is double-buffered, see wl_surface.commit.
 *
 * Setting the exclusive zone to -1 is a special case that overrides
 * the anchoring rules: the compositor will make sure that this surface
 * does not occlude other layer surfaces with a positive exclusive zone,
 * but it may be occluded by other surfaces.
 */
static inline void
zwlr_layer_surface_v1_set_exclusive_zone(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, int32_t zone)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_SET_EXCLUSIVE_ZONE, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, zone);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Requests that the surface be placed some distance away from the anchor
 * point on the output, in surface-local coordinates. Setting this value
 * for edges you are not anchored to has no effect.
 *
 * The exclusive zone includes the margin.
 *
 * Margin is double-buffered, see wl_surface.commit.
 */
static inline void
zwlr_layer_surface_v1_set_margin(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, int32_t top, int32_t right, int32_t bottom, int32_t left)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_SET_MARGIN, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, top, right, bottom, left);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Set how keyboard events are delivered to this surface. By default,
 * layer shell surfaces do not receive keyboard events; this request can
 * be used to enable delivery of keyboard events to a surface.
 *
 * Keyboard events from existing wl_keyboard objects are delivered
 * normally, as long as the keyboard focus is on the layer shell surface.
 * A compositor may also rely on some mechanism to determine the input
 * focus and request keyboard events from additional sources.
 *
 * If keyboard_interactivity is EXCLUSIVE, then the keyboard focus will
 * be taken from the current focus owner, if any.
 *
 * If keyboard_interactivity is ON_DEMAND, then the surface may request
 * keyboard focus using the standard xdg_activation protocol.
 *
 * If keyboard_interactivity is NONE, then the keyboard focus is not
 * taken, and keyboard events are not delivered to this surface.
 *
 * Values set in this way are double-buffered. They will get applied on
 * the next commit.
 */
static inline void
zwlr_layer_surface_v1_set_keyboard_interactivity(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t keyboard_interactivity)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_SET_KEYBOARD_INTERACTIVITY, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, keyboard_interactivity);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * This assigns an xdg_popup's parent to this layer_surface. This popup
 * should have been created via xdg_surface::get_popup with the parent set
 * to NULL, and this request must be invoked before committing the popup's
 * initial state.
 */
static inline void
zwlr_layer_surface_v1_get_popup(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, struct xdg_popup *popup)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_GET_POPUP, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, popup);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * When a configure event is received, if a client commits the
 * surface in response to the configure event, then the client
 * must make an ack_configure request sometime before the commit
 * request, passing along the serial of the configure event.
 *
 * If the client receives multiple configure events before it
 * can respond to one, it only has to ack the last configure event.
 * Acking a configure event that was never sent raises an invalid_serial
 * error.
 *
 * A client is not required to commit immediately after sending an
 * ack_configure request - it may even ack_configure several times
 * before its next surface commit.
 *
 * A client may send multiple ack_configure requests before committing,
 * but only the last request sent before a commit indicates which configure
 * event the client really is responding to.
 */
static inline void
zwlr_layer_surface_v1_ack_configure(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, serial);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * This request destroys the layer surface.
 */
static inline void
zwlr_layer_surface_v1_destroy(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Change the layer that the surface is rendered on.
 *
 * Layer is double-buffered, see wl_surface.commit.
 */
static inline void
zwlr_layer_surface_v1_set_layer(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t layer)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
			 ZWLR_LAYER_SURFACE_V1_SET_LAYER, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, layer);
}

#ifdef  __cplusplus
}
#endif

#endif
